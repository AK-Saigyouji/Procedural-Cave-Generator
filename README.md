# Procedural-Cave-Generator

This is a set of scripts that allow the creation of both 2D and 3D cave meshes in Unity. They can be created either on the fly during gameplay, or saved as prefabs and built upon in the editor. This project was built upon the [Procedural Cave Generator tutorial](https://unity3d.com/learn/tutorials/projects/procedural-cave-generation-tutorial) on the Unity website by Sebastian Lague.

## 1. Using the procedural cave generator

To make use of the project, simply create a new empty game object, and attach two scripts to it: either MapGenerator2D or MapGenerator3D (depending on your needs), and MeshGenerator. To generate a map in the editor, you can run the scene. This will cause two buttons to appear in the inspector for your chosen MapGenerator script: "New Map" and "Create Prefab". New Map will generate a new map based on the parameters set in the inspector. Create Prefab will turn your map into a prefab, and save the required mesh assets along with it in a folder called "GeneratedCave". Once you save one or more maps, you can exit run mode, and drag the created prefab out into the hierarchy to work with it in the editor. 

The MapGenerator scripts have a number of variables in the inspector that can be configured to customize the map. Those requiring explanation are listed here:

* Map Density 

   Determines the approximate proportion of walls. i.e. 0.3 will result in approximately 30% of the map being covered by walls, the rest being open space. Note that due to pruning of small walls and spaces, exact proportion may vary, especially with a very large or small density.

* Seed and Use Random Seed

   If UseRandomSeed is selected, the seed is ignored and the map is generated randomly. Otherwise, the seed is used, ensuring that two maps with the same parameters generated by the same seed will be the same. Can be used to control which maps are generated without storing them in memory. 
   
* Square Size

   Determines how many game units are taken up by each point in the map. Larger numbers will produce larger, more boxy-looking caves.

* Wall Height (3D only)

   Determines the height (in game units) of the walls generated by the 3D map generator. Must be at least 1. 

* Wall Material (3D only) and Ceiling Material

   These control the materials for the two separate components of the cave: the ceiling (top of the walls) and the walls themselves. To control tiling for the walls, use the Tiling properties on the Materials used, particularly if the square size and wall height parameters differ by a significant amount. By default, each flat section of the walls will have the entire texture mapped across it. To control tiling for the ceiling, the MeshGenerator script offers one additional property that can be altered:

* Ceiling Texture Dimensions (on the MeshGenerator script)

   Gives an x and y value corresponding to how the ceiling texture should be applied, implicitly determining tiling. e.g. if the map is 300 by 200 and you're using a texture that is meant to be spread across a 100 by 100 space in game units, then the texture will be tiled a total of 6 times across the map. 
  
## 2. Brief overview of how the generator works

For a detailed explanation with visualizations, check out Sebastian Lague's video series. Note that there are some major differences in how certain things are done compared to this project.

The mapgenerator produces a 2D grid of 0s and 1s, the 1s corresponding to the walls and 0s to spaces. The meshgenerator produces the actual meshes from this grid.

### Map generation

1. Start by creating a 2D grid of noise (distributed uniformly at random, based on the map density). 
2. Do several smoothing passes where each cell becomes more like its neighbors (cellular automata).
3. Prune small regions of walls and space. 
4. Connect all regions of space using a minimum spanning tree algorithm (Kruskal's).
5. Apply a border if applicable (border size > 0).

### Mesh generation

1. Triangulate the grid using the marching squares algorithm (note: this produces a finer grid than the original map, producing smoother looking walls). 
2. Use these triangles to product the ceiling mesh. 
3. Determine the outlines in this map (i.e. the points between interiors of walls and space). 
4. 
  * If the map is 3D, create walls along these outlines for the wall mesh.
  * If the map is 2D, use these outlines to generate edge colliders (offering collision detection). 
5. If the map is 3D, generate a mesh collider using the wall mesh.

## 3. Differences from original project on Unity site

* Allowed the creation of prefabs, so that maps can be used in the editor. This removes the need to generate all game content dynamically, a difficult task for more complicated games. This also makes it far easier to use Unity's lighting and navigation features. 
* The original project broke for maps much larger than 200 by 200, due to Unity's built in limitations on the number of vertices permitted in a single mesh. To fix this, the meshes are now generated in chunks, allowing for the creation of arbitrarily large maps. Additionally, the chunks can be dynamically toggled on/off to improve performance in large maps.
* Decoupled the orientation of outlines (required for the walls to be visible from the right direction) from the marching squares algorithm. This was necessary to break the mesh into chunks. This coupling was arguably the most subtle (and confusing) part of the original project.
* Assigned uvs to the wall mesh, allowing textures to be applied. 
* Created a custom inspector permitting map creation with the press of a button in the inspector. 
* Separated 2D and 3D functionality into separate classes that now inherit from a common abstract class.
* Turned the 16 case switch statement into a lookup table (using an array), significantly speeding up the triangulation process during mesh creation. 
* Fixed a bug with the smoothing function. In the original project, this was done in place. This means once a cell is changed, this change will affects its neighbors when it's their turn. By copying changes into a new map, this issue is avoided.
* Large-scale reorgnanization of the code, introducing many new classes to isolate functionality and improve readability.
* Use of Kruskal's minimum spanning tree algorithm to connect the rooms, resulting in much simpler code than the original method.
* Substantially simpler algorithm for finding the line between two points in the map. 

## 4. Ideas for improvements and new features

* Asynchronous implementation of the algorithm, in order to allow large maps to be generated in the background while playing. Unity targets .NET 3.5 which unfortunately does not include the Task Parallel Library (4.0) or the Async/Await keywords (4.5). 
* Better support for dynamic map generation.
* Better support for applying textures. Depending on the type of texture one applies, one can get strange results that might not be obvious how to diagnose. 
* Currently the map one receives at the end of the algorithm does not reflect the more detailed triangulation constructed during mesh creation. Incorporating the squaregrid into the map will result in a more accurate map.
* The room and connection information processed during map creation can be use to produce a more optimized path-finding algorithm than a direct A* search over the entire map. 
* The map object could be enriched to support more tile-based features, such as holding information about what enemies or items are occupying a given tile. 
* The main computational bottleneck is computing the shortest path between every pair of rooms. Finding a way to optimize this would result in a significant speedup for larger maps. 
