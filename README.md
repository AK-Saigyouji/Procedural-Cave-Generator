# Procedural Cave Generator

This is a set of scripts that allow the creation of both 2D and 3D cave meshes in Unity with collision detection. They can be created either on the fly during gameplay through code, or saved as prefabs and built upon in the editor without touching a line of code. This project heavily expands upon and optimizes the [Procedural Cave Generator](https://unity3d.com/learn/tutorials/projects/procedural-cave-generation-tutorial) on the Unity website by Sebastian Lague.

[A few examples of what these maps look like can be found here.](http://imgur.com/a/jeZHR) 

## 1. Using the procedural cave generator

To make use of the project, create a new empty game object, and attach either CaveGenerator2D or CaveGenerator3D. To generate a map in the editor, you can run the scene. This will cause two buttons to appear in the inspector for your chosen MapGenerator script: "Generate New Map" and "Create Prefab". "Generate New Map" will generate a new map based on the parameters set in the inspector. "Create Prefab" will turn your map into a prefab, and save the required mesh assets along with it in a folder called "GeneratedCave". Once you save one or more maps, you can exit run mode, and drag the created prefab out into the hierarchy to work with it in the editor. 

The MapGenerator scripts have a number of variables in the inspector that can be configured to customize the map. Those requiring explanation are listed here:

* Initial Map Density 

   Determines the initial proportion of walls. i.e. 0.45 will result in approximately 45% of the map being initialized as walls. Note that the final density will differ from the initial: deviation from 0.5 will be magnified. It is recommended to pick a density between .45 and .55 (experiment to see what parameters fit your needs).

* Seed and Use Random Seed

   If UseRandomSeed is selected, the seed is ignored and the map will be generated randomly. Otherwise the seed is used, ensuring that two maps with the same parameters generated by the same seed will be the same. Can be used to control which maps are generated without storing them in memory. 
   
* Square Size

   Determines how many game units are taken up by each point in the map. Larger numbers will produce larger, more boxy-looking caves. Recommended value is 1.

* Wall Height (3D only)

   Determines the height (in game units) of the walls generated by the 3D map generator. Must be at least 1. 

* Wall Material (3D only) and Ceiling Material

   These control the materials for the two separate components of the cave: the ceiling (top of the walls) and the walls themselves. 

The final two parameters affect texture tiling. If a texture is too stretched out or compressed, these variables can be tweaked to adjust that. Additionally, Tiling can be adjusted on the chosen Material itself for further control. 

* Ceiling Texture Dimensions

   Determines ceiling tiling. If the map is 300 by 200 and the dimensions are set to 100 by 100, then the ceiling texture will be tiled 6 times, in each 100 by 100 region. 
   
* Walls Per Texture Tile

   Determines how many sections of wall the wall texture will span before tiling. Reducing this number will increase tiling, increasing it will reduce tiling. 
  
## 2. Brief overview of how the generator works

The following is a quick look under the hood of how the generator works.

### Map generation

1. Start by creating a 2D grid of noise (distributed uniformly at random, based on the initial map density). 
2. Do several smoothing passes where each cell becomes more like its neighbors (cellular automata). 
3. Prune small regions of walls and space. 
4. Connect all regions of space using a minimum spanning tree algorithm.
5. Apply a border if applicable (border size > 0).

### Mesh generation

1. Triangulate the grid using the marching squares algorithm (note: this produces a finer grid than the original map, producing smoother looking walls). 
2. Use these triangles to produce the ceiling mesh. 
3. Determine the outlines in this map (i.e. the points between interiors of walls and space). 
4. 
  * If the map is 3D, create walls along these outlines for the wall mesh.
  * If the map is 2D, use these outlines to generate edge colliders (offering collision detection). 
5. If the map is 3D, generate a mesh collider using the wall mesh.

## 3. Improvements to original project on Unity site

* It is now possible to convert maps into prefabs with the press of a button, allowing content to be placed in the editor. This eliminates the need to generate all game content dynamically, a difficult task for more complicated games. This also makes it easier to use Unity's lighting and navigation features. 
* The original project broke for maps much larger than 200 by 200, due to Unity's built in limitations on the number of vertices permitted in a single mesh. To fix this, the meshes are now generated in chunks, allowing for the creation of arbitrarily large maps. Additionally, the chunks can be dynamically toggled on/off during runtime to improve performance in large maps.
* Assigned uvs to the wall mesh, allowing textures to be applied. 
* Created a custom inspector permitting map creation with the press of a button in the inspector. 
* Separated 2D and 3D functionality into separate attachable scripts.
* Eliminated the need to attach the mesh generator script (in fact, it's no longer attachable at all).
* Fixed a bug with the smoothing function. In the original project, smoothing was done in place. This meant once a cell is changed, this change affected its neighbors when it's their turn. By copying changes into a new map, this issue is avoided.
* Massive reduction in run time and required memory. The entire process has a runtime that is now approximately linear in the number of tiles in the map (i.e. linear in length * width), and enormous maps as large as 1000 by 1000 can be generated in seconds. 
* Large-scale reorganization of the code, simplifying many complex algorithms and splitting functionality across numerous classes. Those seeking to modify the project for their own purposes should find it easier. 
